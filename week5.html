<h2 class="entrytitle">Fifth week (July 1st, 2017)</h2>
<h3>
	<bold>Integrating weave code generation with GSL</bold>
</h3>
<p type="entrytext">
Things I needed to solve to make this work:
<ul>
<li> 
The 'code' in device.py is not just text, but a class that has different parts of the code such as 'main' and 'support'. So when hacking in manually written code - to test what I have in mind for what the code should look like and the end of the code generation process - we have to write the support and main in separate files and set the class variables describing these parts to the correspondng text. </li>
<li> 
Obviously one big thing that needed to change was the syntax of the code produces by the template functions. Luckily, these syntax differences are quite easy to translate. So easy, in fact, that it was possible to write one function for both target languages leaving certain bits of code variable, in this way:
<div class="code"><pre><code>
for var in diff_vars:
diff_num = diff_vars[var]
array_name = variable_mapping[var]['pointer']
to_replace['{cpp_pre}_gsl_{var}_f{ind}'.format(cpp_pre=''+'const double '*cpp,
                                               var=var,
                                               ind=diff_num)] = 'f[{ind}]'.format(ind=diff_num)
func_fill_yvector += ['\ty[{ind}] = p{ptrstr}{var}[_idx]{endstr}'.format(ind=diff_num,
                                                                         ptrstr='{ptr}',
                                                                         var=array_name,
                                                                         endstr='{end}')]
</code></pre></div>
after adding everything to one big string, I format it with a dictionary that has all the values that belong to one of the two target languages. Examples for string created by the code above for either code:
<div class="code"><pre><code>
cython:
replace '_gsl_v_f0' with 'f[0]'
add 'y[0] = p._array_neurongroup_v[_idx]'

weave:
replace 'const double _gsl_v_f0' with 'f[0]'
add 'y[0] = p->_ptr_array_neurongroup_v[_idx];'
</code></pre></div>
More examples of syntax differences between the two languages are the opening and closing of functions (cython with :, weave with {}) and the casting of pointers (cython with &lt;&gt;, weave with ()). See the functions 'write_GSL_support_code' and add_GSL_scalar_code_and_declarations' <a href="https://github.com/CharleeSF/brian2/blob/f9590b2715da54cee4068a204f329c2ee61595f8/brian2/codegen/templates.py#L112" target="_blank">here</a> for the full code.
</li>
<li>
In the cpp code that brian generates when using weave there are some additional differences to the code generated by cython. For one, the variables are not explicitly 'loaded' from namespace in the form of <code class="code">double a = _namespace["a"]</code> (or if it does it's not in the main or support_coee and I haven't found it or ran into any problems of undefined variables). Further, the cpp code refers to the arrays of neural state variables with two different names. Examples of either would be: _array_neurongroup_v and _ptr_array_neurongroup_v. Exactly why this is is still a bit unclear to me; a comment in brian about it reads as follows: <code class="clode"> # set up the restricted pointers, these are used so that the compiler knows there is no aliasing in the pointers, for optimisation</code>. However, it means that our templater needs to know two different references to one array, that are both generated according to a different function (<code class="code">device.get_array_name(var)</code> for the 'brian' array name, and <code class="code">self.get_array_name(var)</code> (where self is the generator) for the 'pointer' array name). I thought about sending the generator to the templater so these functions could be called in the templater. However, for now I decided to just send more keywords to the templater and save both forms in a dictionary (because I needed more and more keywords for the templater I also put all of them together in an 'extra_information' dictionary). Additionally, I add the information whether the variables are 'restricted' or not.
</li>
</ul>
Finally there were a few bugs I ran into that took me a bit to figure out. One of them was that I forgot to set p._idx to _idx in the integration loop, and although setting for example <code class="code">const double a = p._ptr_array_neurongroup_a[p._idx]</code> did not raise an array, I got a segmentation fault when I was actually trying to use the variable. A second bug that confused me for a while was a mistake in indentation in one of the cython templates.
</p>
<p class="entrytext">
I guess next week I will be working on getting the standalone version of cpp to run. Other than this there is still plenty to think about. Like.. How to create all the new functionality as a separate function? And can we let Brian set the CodeObject rather than having to set <code class="code">neurongroup.state_updater.codeobj_class = GSLWeaveCodeObject</code> ourselves. For the rest there is also the settings of the drivers that we need to look in to. What are good values for the absolute- and relative error? What are good integrators to use? Answers to these questions are important when it comes to actually making the GSL interface useful. The integration is already going to be slower compared to brian integration with similar timesteps, but hopefully we can gain other benefits such as being able to integrate with bigger timesteps without losing stability (especially with hodgkin-huxley).
</p>
